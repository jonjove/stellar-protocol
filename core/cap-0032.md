## Preamble

```
CAP: 0032
Title: Preauthorization of TrustLines
Author: Jonathan Jove
Status: Draft
Created: 2020-03-31
Discussion: <link to where discussion for this CAP is taking place, typically the mailing list>
Protocol version: TBD
```

## Simple Summary
This proposal makes it possible to authorize a trust line before it is created.

## Motivation
This proposal seeks to solve the following problem: an issuer should be able to
authorize a trust line without waiting for the trust line to be created.

Consider, for example, an issuer that wants to issue `AUTH_REQUIRED` assets to
an account that does not have a trust line for the asset. With the current
version of the protocol, the issuer will need to wait until the account has
created a trust line before authorizing the trust line. This presents friction
to the issuer, which must now employ additional machinery to either monitor the
ledger or use pre-signed/pre-authorized transactions. In either case, complexity
is increased for an operation fundamental to the network.

### Goals Alignment
This proposal is aligned with several Stellar Network Goals, among them:

- The Stellar Network should make it easy for developers of Stellar projects to
  create highly usable products.
- The Stellar Network should enable cross-border payments, i.e. payments via
  exchange of assets, throughout the globe, enabling users to make payments
  between assets in a manner that is fast, cheap, and highly usable.
    - In support of this, the Stellar Network should enable asset issuance, but
      as a means of enabling cross-border payments.

## Abstract
We introduce `PreauthorizationEntry` as a new type of `LedgerEntry` which
represents authorization to hold an asset before the corresponding trust line is
created. The operation `CreatePreauthorizationOp` makes it possible to create a
`PreauthorizationEntry` whereas the operation `RemovePreauthorizationOp` makes
it possible to remove a `PreauthorizationEntry`. A `PreauthorizationEntry` can
be converted implicitly into a trust line by `ChangeTrustOp`, and `AllowTrustOp`
can be used to change the authorization level.

## Specification

### XDR

#### PreauthorizationEntry
```c++
struct LedgerEntryType
{
    // ... ACCOUNT, TRUSTLINE, OFFER, DATA unchanged ...
    SPONSORSHIP = 4,
    PREAUTHORIZATION = 5
};

struct PreauthorizationEntry
{
    // Account for which the preauthorization applies
    AccountID accountID;

    // Asset for which the preauthorization applies
    Asset asset;

    // reserved for future use
    union switch (int v)
    {
    case 0:
        void;
    }
    ext;
};

struct LedgerEntry
{
    uint32 lastModifiedLedgerSeq; // ledger the LedgerEntry was last changed

    union switch (LedgerEntryType type)
    {
    // ... ACCOUNT, TRUSTLINE, OFFER, DATA, SPONSORSHIP unchanged ...
    case PREAUTHORIZATION:
        PreauthorizationEntry preauthorization;
    }
    data;

    // reserved for future use
    union switch (int v)
    {
    case 0:
        void;
    }
    ext;
};
```

#### SponsorshipEntry
```c++
struct SponsorshipType
{
    ACCOUNT = 0,
    SIGNER = 1,
    TRUSTLINE = 2,
    OFFER = 3,
    DATA = 4,
    PREAUTHORIZATION = 5
};

struct PreauthorizationSponsorship
{
    // Account to preauthorize
    AccountID accountID;

    // Preauthorization asset
    Asset asset;

    // Authorization flags
    uint32 flags;
};

union SponsorshipDescriptor (SponsorshipType type)
{
// ... ACCOUNT, SIGNER, TRUSTLINE, OFFERS, DATA unchanged ...
case PREAUTHORIZATION:
    PreauthorizationSponsorship preauthorization;
};
```

#### Operations
```c++
enum OperationType
{
    // ... CREATE_ACCOUNT, ..., CREATE_SPONSORSHIP unchanged ...
    REMOVE_SPONSORSHIP = 15,
    CREATE_PREAUTHORIZATION = 16,
    REMOVE_PREAUTHORIZATION = 17
};

struct CreatePreauthorizationOp
{
    // Account to preauthorize
    AccountID accountID;

    // Preauthorization asset
    Asset asset;
};

struct RemovePreauthorizationOp
{
    // Account from which to remove preauthorization
    AccountID accountID;

    // Preauthorization asset
    Asset asset;
};

struct Operation
{
    // sourceAccount is the account used to run the operation
    // if not set, the runtime defaults to "sourceAccount" specified at
    // the transaction level
    AccountID* sourceAccount;

    union switch (OperationType type)
    {
    // ... CREATE_ACOUNT, ..., REMOVE_SPONSORSHIP unchanged ...
    case CREATE_PREAUTHORIZATION:
        CreatePreauthorizationOp createPreauthorizationOp;
    case REMOVE_PREAUTHORIZATION:
        RemovePreauthorizationOp removePreauthorizationOp;
    }
    body;
};
```

#### Operation Results
```c++
enum CreatePreauthorizationResultCode
{
    CREATE_PREAUTHORIZATION_SUCCESS = 0,
    CREATE_PREAUTHORIZATION_MALFORMED = -1,
    CREATE_PREAUTHORIZATION_NOT_SPONSORED = -2
};

union CreatePreauthorizationResult switch (CreatePreauthorizationResultCode code)
{
case CREATE_PREAUTHORIZATION_SUCCESS:
    void;
default:
    void;
};

enum RemovePreauthorizationResultCode
{
    REMOVE_PREAUTHORIZATION_SUCCESS = 0,
    REMOVE_PREAUTHORIZATION_DOES_NOT_EXIST = -1
};

union RemovePreauthorizationResult switch (RemovePreauthorizationResultCode code)
{
case REMOVE_PREAUTHORIZATION_SUCCESS:
    void;
default:
    void;
};

struct OperationResult
{
    // sourceAccount is the account used to run the operation
    // if not set, the runtime defaults to "sourceAccount" specified at
    // the transaction level
    AccountID* sourceAccount;

    union switch (OperationType type)
    {
    // ... CREATE_ACOUNT, ..., REMOVE_SPONSORSHIP unchanged ...
    case CREATE_PREAUTHORIZATION:
        CreatePreauthorizationResult createPreauthorizationResult;
    case REMOVE_PREAUTHORIZATIOn:
        RemovePreauthorizationResult removePreauthorizationResult;
    }
    body;
};
```

### Semantics

#### CreatePreauthorizationOp
A `PreauthorizationEntry` can only be created by the `CreatePreauthorizationOp`
operation. Note that `CreatePreauthorizationOp` succeeds if and only if a
subsequent use of `AllowTrustOp` would be successful. Specifically, this means
that the operation succeeds even if a matching `PreauthorizationEntry` or
`TrustLineEntry` already exists. `CreatePreauthorizationOp` is invalid with
`CREATE_PREAUTHORIZATION_MALFORMED` if

- `asset` is of type `ASSET_TYPE_NATIVE`
- `asset` is invalid
- `sourceAccount` is not the issuer of `asset`

The behavior of `CreatePreauthorizationOp` is as follows:

1. Succeed with `CREATE_PREAUTHORIZATION_SUCCESS`
    - if a trust line with the specified `accountID` and `asset` exists
    - if a `PreauthorizationEntry` with the specified `accountID` and `asset`
      exists
2. Fail with `CREATE_PREAUTHORIZATION_NOT_SPONSORED` if there does not exist a
   `SponsorshipEntry` with `descriptor.type() == PREAUTHORIZATION`,
   `descriptor.preauthorization().accountID == accountID`, and
   `descriptor.preauthorization().asset == asset`
3. Create a `PreauthorizationEntry` as `preauthorization` with the following
   properties:
    - `preauthorization.accountID = accountID`
    - `preauthorization.asset = asset`
    - `flags = !(sourceAccount.flags & AUTH_REQUIRED_FLAG)`
4. Succeed with `CREATE_PREAUTHORIZATION_SUCCESS`

`CreatePreauthorizationOp` requires low threshold because it cannot be used to
send funds.

#### RemovePreauthorizationOp
A `PreauthorizationEntry` can only be removed (rather than converted) by the
`RemovePreauthorizationOp` operation. `RemovePreauthorizationOp` is invalid with
`REMOVE_PREAUTHORIZATION_MALFORMED` if

- `asset` is of type `ASSET_TYPE_NATIVE`
- `asset` is invalid
- `sourceAccount` is not the issuer of `asset`

The behavior of `RemovePreauthorizationOp` is as follows:

1. Fail with `REMOVE_PREAUTHORIZATION_DOES_NOT_EXIST` if there does not exist a
   `PreauthorizationEntry` with the specified `accountID` and `asset`
2. Remove the specified `PreauthorizationEntry`
3. Succeed with `REMOVE_PREAUTHORIZATION_SUCCESS`

`RemovePreauthorizationOp` requires low threshold because it cannot be used to
send funds.

## Design Rationale

### Preauthorization Entry Must be Sponsored
One of the main requirements governing the structure of this proposal is that
the `CreatePreauthorizationOp` and `RemovePreauthorizationOp` should require low
threshold. Consider, for example, an entity that wants to guarantee that they
will issue and maintain a fixed supply of an `AUTH_REQUIRED` asset. The issuer
can create an issuing account, which will be the actual issuer of the asset, and
a distribution account, which will hold the supply that has not yet been issued.
The issuing account will send a payment of the asset to the distribution account
then set its thresholds such that it is impossible to satisfy medium or high
threshold. This guarantees the intergrity of the supply, but also implies that
all operations related to authorization should require low threshold in order to
be usable.

TODO(jonjove)
